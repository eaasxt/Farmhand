#!/bin/bash
#
# MCP Agent Mail Health Check + Stale Reservation Cleanup
# --------------------------------------------------------
# 1. Checks if MCP Agent Mail server is responding
# 2. Restarts the service if it fails 3 consecutive times
# 3. Cleans up expired/stale reservations from the database
#
# Usage: Called by systemd timer (mcp-health-check.timer)
#        Or manually: mcp-health-check
#

set -euo pipefail

ENDPOINT="${MCP_AGENT_MAIL_URL:-http://127.0.0.1:8765/mcp/}"
MAX_RETRIES=3
RETRY_DELAY=2
STATE_FILE="/tmp/mcp-health-check.failures"
DB_PATH="${HOME}/mcp_agent_mail/storage.sqlite3"
STALE_HOURS=4  # Reservations older than this are considered stale

log() {
    logger -t "mcp-health-check" "$1"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Read current failure count
get_failure_count() {
    if [[ -f "$STATE_FILE" ]]; then
        cat "$STATE_FILE"
    else
        echo "0"
    fi
}

# Update failure count
set_failure_count() {
    echo "$1" > "$STATE_FILE"
}

# Check if MCP is responding
check_health() {
    # Simple connectivity check - just see if the port is open and responding
    if curl -sf -o /dev/null --connect-timeout 5 "$ENDPOINT" 2>/dev/null; then
        return 0
    fi
    return 1
}

# Clean up expired and stale reservations from the database
cleanup_stale_reservations() {
    if [[ ! -f "$DB_PATH" ]]; then
        return 0
    fi

    # Get current UTC timestamp
    local now
    now=$(date -u '+%Y-%m-%d %H:%M:%S')
    
    # Calculate stale threshold (STALE_HOURS ago)
    local stale_threshold
    stale_threshold=$(date -u -d "${STALE_HOURS} hours ago" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
                      date -u -v-${STALE_HOURS}H '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
                      echo "")
    
    if [[ -z "$stale_threshold" ]]; then
        # Fallback if date manipulation fails
        return 0
    fi

    # Count and delete expired reservations (past expires_ts)
    local expired_count
    expired_count=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM file_reservations WHERE released_ts IS NULL AND expires_ts < '$now';" 2>/dev/null || echo "0")
    
    if [[ "$expired_count" -gt 0 ]]; then
        sqlite3 "$DB_PATH" "UPDATE file_reservations SET released_ts = '$now' WHERE released_ts IS NULL AND expires_ts < '$now';" 2>/dev/null
        log "Cleaned up $expired_count expired reservations"
    fi

    # Count and delete stale reservations (created > STALE_HOURS ago and not released)
    local stale_count
    stale_count=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM file_reservations WHERE released_ts IS NULL AND created_ts < '$stale_threshold';" 2>/dev/null || echo "0")
    
    if [[ "$stale_count" -gt 0 ]]; then
        sqlite3 "$DB_PATH" "UPDATE file_reservations SET released_ts = '$now' WHERE released_ts IS NULL AND created_ts < '$stale_threshold';" 2>/dev/null
        log "Cleaned up $stale_count stale reservations (older than ${STALE_HOURS}h)"
    fi
}

# Main health check logic
main() {
    local failures
    failures=$(get_failure_count)

    for i in $(seq 1 $MAX_RETRIES); do
        if check_health; then
            # Success - reset failure count
            if [[ "$failures" != "0" ]]; then
                log "MCP Agent Mail recovered after $failures failures"
            fi
            set_failure_count 0
            
            # Run cleanup on successful health check
            cleanup_stale_reservations
            
            exit 0
        fi

        if [[ $i -lt $MAX_RETRIES ]]; then
            sleep $RETRY_DELAY
        fi
    done

    # All retries failed
    failures=$((failures + 1))
    set_failure_count "$failures"

    log "MCP Agent Mail unresponsive (failure #$failures)"

    if [[ $failures -ge 3 ]]; then
        log "MCP Agent Mail failed 3+ times, restarting service..."
        if sudo systemctl restart mcp-agent-mail 2>/dev/null; then
            log "MCP Agent Mail service restarted"
            set_failure_count 0
        else
            log "ERROR: Failed to restart MCP Agent Mail service"
            exit 1
        fi
    fi

    exit 0
}

main "$@"
