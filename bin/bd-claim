#!/usr/bin/env python3
"""
bd-claim: Atomically claim a bead and reserve files.

Part of Farmhand - Multi-agent AI coding infrastructure.

This script:
1. Validates agent registration (queries MCP directly)
2. Validates bead is claimable (status=open)
3. Reserves files via MCP Agent Mail
4. Updates bead status and assignee via bd CLI
5. Updates local state file (for hook compatibility)

If file reservation succeeds but bead update fails, reservations are
automatically released (rollback).

Usage:
    bd-claim <bead-id> [--paths <globs>] [--ttl <seconds>] [--json]

Examples:
    bd-claim bd-a1b2 --paths "src/**/*.py"
    bd-claim bd-a1b2 --paths "src/**/*.py,tests/**/*.py" --ttl 7200
    bd-claim bd-a1b2 --json
"""

import argparse
import json
import os
import subprocess
import sys
import time
import fcntl
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Optional
from contextlib import contextmanager

# Add parent directory to path for lib imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from lib.mcp_client import MCPClient, MCPError, get_project_key


# =============================================================================
# Configuration
# =============================================================================

DEFAULT_TTL = 3600  # 1 hour


def get_state_dir() -> Path:
    """Get the state directory, respecting HOME env var at runtime."""
    return Path.home() / ".claude"

# Lock configuration (matching mcp-state-tracker.py)
LOCK_TIMEOUT = 5.0  # seconds to wait for lock
LOCK_RETRY_DELAY = 0.1  # seconds between retry attempts


# =============================================================================
# File Locking (from mcp-state-tracker.py for consistency)
# =============================================================================

@contextmanager
def state_lock(lock_file: Path, timeout: float = LOCK_TIMEOUT):
    """Context manager for exclusive lock on state file operations."""
    lock_file.parent.mkdir(parents=True, exist_ok=True)

    start_time = time.time()
    fd = None

    try:
        fd = os.open(str(lock_file), os.O_RDWR | os.O_CREAT)

        while True:
            try:
                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
                break
            except BlockingIOError:
                elapsed = time.time() - start_time
                if elapsed >= timeout:
                    raise TimeoutError(f"Could not acquire state lock after {timeout}s")
                time.sleep(LOCK_RETRY_DELAY)

        lock_file.touch()
        yield

    finally:
        if fd is not None:
            try:
                fcntl.flock(fd, fcntl.LOCK_UN)
            except OSError:
                pass
            try:
                os.close(fd)
            except OSError:
                pass


def get_state_file() -> Path:
    """Get the state file path for this agent."""
    state_dir = get_state_dir()
    agent_name = os.environ.get("AGENT_NAME")
    if agent_name:
        return state_dir / f"state-{agent_name}.json"
    return state_dir / "agent-state.json"


def get_lock_file() -> Path:
    """Get the lock file path for this agent's state file."""
    return get_state_file().with_suffix('.lock')


def load_state() -> dict:
    """Load agent state from file."""
    state_file = get_state_file()
    if state_file.exists():
        try:
            with open(state_file, encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            pass
    return {}


def save_state(state: dict) -> None:
    """Save agent state to file with atomic write and locking."""
    state_file = get_state_file()
    lock_file = get_lock_file()
    get_state_dir().mkdir(parents=True, exist_ok=True)

    with state_lock(lock_file):
        temp_file = state_file.with_suffix('.tmp')
        try:
            with open(temp_file, "w", encoding='utf-8') as f:
                json.dump(state, f, indent=2)
            temp_file.rename(state_file)
        except IOError:
            if temp_file.exists():
                temp_file.unlink()
            raise


def get_agent_name(client: MCPClient) -> Optional[str]:
    """
    Get agent name for MCP operations.

    Priority:
    1. State file (if registered=True and agent_name exists)
    2. MCP query by pane name (if AGENT_NAME env var set)
    3. None (not registered)

    The AGENT_NAME env var is used for state file path selection AND
    for finding the agent in MCP if state file is stale.
    """
    # First check state file
    state = load_state()
    if state.get("registered") and state.get("agent_name"):
        # Verify agent still exists in MCP
        project_key = get_project_key()
        try:
            agent = client.find_agent_by_name(project_key, state["agent_name"])
            if agent:
                return state["agent_name"]
        except MCPError:
            pass  # Project doesn't exist or MCP unavailable

    # Try to find by pane name
    pane_name = os.environ.get("AGENT_NAME")
    if pane_name:
        project_key = get_project_key()
        try:
            agent = client.find_agent_by_pane(project_key, pane_name)
            if agent:
                # Update state file with discovered agent
                mcp_name = agent.get("name")
                if mcp_name:
                    state["registered"] = True
                    state["agent_name"] = mcp_name
                    state["pane_name"] = pane_name
                    try:
                        save_state(state)
                    except (IOError, TimeoutError):
                        pass  # Best effort
                    return mcp_name
        except MCPError:
            pass  # Project doesn't exist or MCP unavailable

    return None


# =============================================================================
# Bead Operations (via bd CLI)
# =============================================================================

def get_bead(bead_id: str) -> Optional[dict]:
    """Fetch bead details via bd CLI."""
    try:
        result = subprocess.run(
            ["bd", "show", bead_id, "--json"],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            data = json.loads(result.stdout)
            # bd show --json returns an array with one element
            if isinstance(data, list) and len(data) > 0:
                return data[0]
            elif isinstance(data, dict):
                return data
        return None
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        return None


def update_bead_status(bead_id: str, agent_name: str) -> dict:
    """Update bead status to in_progress with assignee."""
    try:
        result = subprocess.run(
            ["bd", "update", bead_id,
             "--status", "in_progress",
             "--assignee", agent_name],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            return {"success": True}
        return {"error": result.stderr.strip() or "Update failed"}
    except subprocess.TimeoutExpired:
        return {"error": "bd update timed out"}
    except FileNotFoundError:
        return {"error": "bd command not found"}


# =============================================================================
# MCP Agent Mail Operations (via lib/mcp_client)
# =============================================================================

def reserve_files(client: MCPClient, agent_name: str, paths: list, ttl: int, reason: str) -> dict:
    """Reserve files via MCP Agent Mail."""
    try:
        return client.reserve_files(
            project_key=get_project_key(),
            agent_name=agent_name,
            paths=paths,
            ttl_seconds=ttl,
            exclusive=True,
            reason=reason
        )
    except MCPError as e:
        return {"error": str(e)}


def release_files(client: MCPClient, agent_name: str) -> dict:
    """Release file reservations (rollback helper)."""
    try:
        return client.release_files(
            project_key=get_project_key(),
            agent_name=agent_name
        )
    except MCPError as e:
        return {"error": str(e)}


# =============================================================================
# Main Logic
# =============================================================================

def claim(bead_id: str, paths: Optional[list], ttl: int, json_output: bool) -> int:
    """Atomically claim a bead and reserve files. Returns exit code."""

    # Initialize MCP client
    client = MCPClient()

    # Step 1: Validate agent registration
    agent_name = get_agent_name(client)
    if not agent_name:
        pane_name = os.environ.get("AGENT_NAME", "unknown")
        project_key = get_project_key()
        error = {
            "success": False,
            "error": "Agent not registered with MCP Agent Mail",
            "details": f"Pane '{pane_name}' has not registered. Run register_agent() or macro_start_session() first.",
            "hint": "Registration assigns you a memorable name (e.g., 'ChartreuseLake') used for file reservations.",
            "bead_id": bead_id,
            "state_file": str(get_state_file())
        }
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print("✗ Agent not registered with MCP Agent Mail\n")
            print(f"  Your pane: {pane_name}")
            print(f"  State file: {get_state_file()}")
            print()
            print("  Run register_agent() or macro_start_session() first.")
            print("  This assigns you a memorable name (e.g., 'BlueLake') for file reservations.")
            print()
            print(f'  register_agent(project_key="{project_key}", program="claude-code", model="opus-4.5")')
        return 1

    # Step 2: Validate bead exists and is claimable
    bead = get_bead(bead_id)
    if not bead:
        error = {"success": False, "error": "Bead not found", "bead_id": bead_id}
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print(f"✗ Bead not found: {bead_id}\n")
            print("  Check the ID and try again: bd list")
        return 1

    bead_status = bead.get("status", "").lower()
    if bead_status != "open":
        error = {
            "success": False,
            "error": "Bead not claimable",
            "details": f"Current status is '{bead_status}', must be 'open'",
            "bead_id": bead_id,
            "current_status": bead_status
        }
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print(f"✗ Bead {bead_id} is not claimable\n")
            print(f"  Current status: {bead_status}")
            print(f"  Only beads with status 'open' can be claimed.")
            if bead_status == "in_progress":
                assignee = bead.get("assignee", "unknown")
                print(f"  Currently assigned to: {assignee}")
        return 1

    # Step 3: Reserve files (if paths provided)
    reservation_made = False
    if paths:
        reservation = reserve_files(client, agent_name, paths, ttl, bead_id)

        if "error" in reservation:
            error = {
                "success": False,
                "error": "File reservation failed",
                "details": reservation["error"],
                "bead_id": bead_id
            }
            if json_output:
                print(json.dumps(error, indent=2))
            else:
                print(f"✗ Failed to claim {bead_id}\n")
                print(f"  File reservation failed: {reservation['error']}\n")
                print("  Options:")
                print("  1. Wait for the other agent to release")
                print("  2. Message them via Agent Mail")
                print("  3. Choose a different bead: bd ready")
            return 1

        conflicts = reservation.get("conflicts", [])
        if conflicts:
            error = {
                "success": False,
                "error": "File reservation conflict",
                "details": conflicts,
                "bead_id": bead_id
            }
            if json_output:
                print(json.dumps(error, indent=2))
            else:
                print(f"✗ Failed to claim {bead_id}\n")
                print("  File reservation conflict:")
                for conflict in conflicts:
                    path = conflict.get("path", "unknown")
                    holders = conflict.get("holders", [])
                    holder_info = ", ".join(holders) if holders else "another agent"
                    print(f"    {path} reserved by {holder_info}")
                print("\n  Options:")
                print("  1. Wait for the other agent to release")
                print("  2. Message them via Agent Mail")
                print("  3. Choose a different bead: bd ready")
            return 1

        reservation_made = True

    # Step 4: Update bead status and assignee
    update_result = update_bead_status(bead_id, agent_name)

    if "error" in update_result:
        if reservation_made:
            release_files(client, agent_name)  # Rollback

        error = {
            "success": False,
            "error": "Bead update failed",
            "details": update_result["error"],
            "bead_id": bead_id,
            "rollback": "File reservations released" if reservation_made else None
        }
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print(f"✗ Failed to update {bead_id}\n")
            print(f"  Error: {update_result['error']}")
            if reservation_made:
                print("  (File reservations have been released)")
        return 1

    # Step 5: Update local state file
    try:
        state = load_state()
        state["issue_id"] = bead_id
        state["reservations"] = [{"paths": paths, "reason": bead_id}] if paths else []
        state["claim_time"] = time.time()
        save_state(state)
    except (IOError, TimeoutError) as e:
        if not json_output:
            print(f"  Warning: Could not update state file: {e}")

    # Step 6: Success
    project_key = get_project_key()
    expires_at = datetime.now(timezone.utc) + timedelta(seconds=ttl)

    success = {
        "success": True,
        "bead_id": bead_id,
        "title": bead.get("title", ""),
        "status": "in_progress",
        "assignee": agent_name,
        "files_reserved": paths or [],
        "ttl_seconds": ttl if paths else None,
        "expires_at": expires_at.isoformat() if paths else None,
        "agent": agent_name,
        "project_key": project_key
    }

    if json_output:
        print(json.dumps(success, indent=2))
    else:
        print(f"✓ Claimed {bead_id}: \"{bead.get('title', '')}\"")
        print(f"  Status:    in_progress")
        print(f"  Assignee:  {agent_name}")
        if paths:
            print(f"  Files:     {', '.join(paths)}")
            hours = ttl // 3600
            minutes = (ttl % 3600) // 60
            ttl_str = f"{hours}h {minutes}m" if hours else f"{minutes}m"
            print(f"  TTL:       {ttl_str} (expires {expires_at.strftime('%H:%M')})")
        print(f"  Project:   {project_key}")

    return 0


# =============================================================================
# Entry Point
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Atomically claim a bead and reserve files",
        prog="bd-claim",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  bd-claim bd-a1b2 --paths "src/**/*.py"
  bd-claim bd-a1b2 --paths "src/**/*.py,tests/**/*.py" --ttl 7200
  bd-claim bd-a1b2 --json

This command:
  1. Validates you are registered with MCP Agent Mail
  2. Checks the bead exists and has status 'open'
  3. Reserves the specified files (if --paths provided)
  4. Updates the bead status to 'in_progress' with you as assignee
  5. Updates your local state file

If file reservation succeeds but bead update fails, the reservations
are automatically released (atomic rollback).
        """
    )

    parser.add_argument("bead_id", help="Bead ID to claim (e.g., bd-a1b2)")
    parser.add_argument("--paths", "-p",
        help="Comma-separated glob patterns for file reservation")
    parser.add_argument("--ttl", "-t", type=int, default=DEFAULT_TTL,
        help=f"Reservation TTL in seconds (default: {DEFAULT_TTL})")
    parser.add_argument("--json", action="store_true", dest="json_output",
        help="Output JSON instead of human-readable text")

    args = parser.parse_args()

    paths = None
    if args.paths:
        paths = [p.strip() for p in args.paths.split(",") if p.strip()]

    sys.exit(claim(args.bead_id, paths, args.ttl, args.json_output))


if __name__ == "__main__":
    main()
