#!/usr/bin/env python3
"""
bd-claim: Atomically claim a bead and reserve files.

Part of Farmhand - Multi-agent AI coding infrastructure.

This script:
1. Validates agent registration
2. Validates bead is claimable (status=open)
3. Reserves files via MCP Agent Mail HTTP API
4. Updates bead status and assignee via bd CLI
5. Updates local state file

If file reservation succeeds but bead update fails, reservations are
automatically released (rollback).

Usage:
    bd-claim <bead-id> [--paths <globs>] [--ttl <seconds>] [--json]

Examples:
    bd-claim bd-a1b2 --paths "src/**/*.py"
    bd-claim bd-a1b2 --paths "src/**/*.py,tests/**/*.py" --ttl 7200
    bd-claim bd-a1b2 --json
"""

import argparse
import json
import os
import subprocess
import sys
import time
import fcntl
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Optional
from contextlib import contextmanager

# Optional: use requests if available, fall back to urllib
try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    import urllib.request
    import urllib.error
    HAS_REQUESTS = False


# =============================================================================
# Configuration
# =============================================================================

DEFAULT_TTL = 3600  # 1 hour
MCP_ENDPOINT_DEFAULT = "http://127.0.0.1:8765/mcp/"
STATE_DIR = Path.home() / ".claude"
MCP_ENV_FILE = Path.home() / "mcp_agent_mail" / ".env"

# Lock configuration (matching mcp-state-tracker.py)
LOCK_TIMEOUT = 5.0  # seconds to wait for lock
LOCK_RETRY_DELAY = 0.1  # seconds between retry attempts


# =============================================================================
# File Locking (from mcp-state-tracker.py for consistency)
# =============================================================================

@contextmanager
def state_lock(lock_file: Path, timeout: float = LOCK_TIMEOUT):
    """Context manager for exclusive lock on state file operations."""
    lock_file.parent.mkdir(parents=True, exist_ok=True)

    start_time = time.time()
    fd = None

    try:
        fd = os.open(str(lock_file), os.O_RDWR | os.O_CREAT)

        while True:
            try:
                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
                break
            except BlockingIOError:
                elapsed = time.time() - start_time
                if elapsed >= timeout:
                    raise TimeoutError(f"Could not acquire state lock after {timeout}s")
                time.sleep(LOCK_RETRY_DELAY)

        lock_file.touch()
        yield

    finally:
        if fd is not None:
            try:
                fcntl.flock(fd, fcntl.LOCK_UN)
            except OSError:
                pass
            try:
                os.close(fd)
            except OSError:
                pass


# =============================================================================
# Utilities
# =============================================================================

def get_mcp_endpoint() -> str:
    """Get MCP Agent Mail endpoint from env or default."""
    return os.environ.get("MCP_AGENT_MAIL_URL", MCP_ENDPOINT_DEFAULT)


def get_bearer_token() -> Optional[str]:
    """Read bearer token from MCP Agent Mail .env file."""
    if not MCP_ENV_FILE.exists():
        return None

    try:
        with open(MCP_ENV_FILE) as f:
            for line in f:
                line = line.strip()
                if line.startswith("HTTP_BEARER_TOKEN="):
                    token = line.split("=", 1)[1].strip()
                    if token.startswith('"') and token.endswith('"'):
                        token = token[1:-1]
                    elif token.startswith("'") and token.endswith("'"):
                        token = token[1:-1]
                    return token
    except IOError:
        pass
    return None


def get_project_key() -> str:
    """Get project key with priority: env var, git root, cwd."""
    if "FARMHAND_PROJECT_KEY" in os.environ:
        return os.environ["FARMHAND_PROJECT_KEY"]

    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

    return os.getcwd()


def get_state_file() -> Path:
    """Get the state file path for this agent."""
    agent_name = os.environ.get("AGENT_NAME")
    if agent_name:
        return STATE_DIR / f"state-{agent_name}.json"
    return STATE_DIR / "agent-state.json"


def get_lock_file() -> Path:
    """Get the lock file path for this agent's state file."""
    return get_state_file().with_suffix('.lock')


def load_state() -> dict:
    """Load agent state from file."""
    state_file = get_state_file()
    if state_file.exists():
        try:
            with open(state_file, encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            pass
    return {}


def save_state(state: dict) -> None:
    """Save agent state to file with atomic write and locking."""
    state_file = get_state_file()
    lock_file = get_lock_file()
    STATE_DIR.mkdir(parents=True, exist_ok=True)

    with state_lock(lock_file):
        temp_file = state_file.with_suffix('.tmp')
        try:
            with open(temp_file, "w", encoding='utf-8') as f:
                json.dump(state, f, indent=2)
            temp_file.rename(state_file)
        except IOError:
            if temp_file.exists():
                temp_file.unlink()
            raise


def get_agent_name() -> Optional[str]:
    """Get agent name: from state file or AGENT_NAME env var."""
    state = load_state()
    if state.get("registered") and state.get("agent_name"):
        return state["agent_name"]
    return os.environ.get("AGENT_NAME")


# =============================================================================
# Bead Operations (via bd CLI)
# =============================================================================

def get_bead(bead_id: str) -> Optional[dict]:
    """Fetch bead details via bd CLI."""
    try:
        result = subprocess.run(
            ["bd", "show", bead_id, "--json"],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            data = json.loads(result.stdout)
            # bd show --json returns an array with one element
            if isinstance(data, list) and len(data) > 0:
                return data[0]
            elif isinstance(data, dict):
                return data
        return None
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        return None


def update_bead_status(bead_id: str, agent_name: str) -> dict:
    """Update bead status to in_progress with assignee."""
    try:
        result = subprocess.run(
            ["bd", "update", bead_id,
             "--status", "in_progress",
             "--assignee", agent_name],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            return {"success": True}
        return {"error": result.stderr.strip() or "Update failed"}
    except subprocess.TimeoutExpired:
        return {"error": "bd update timed out"}
    except FileNotFoundError:
        return {"error": "bd command not found"}


# =============================================================================
# MCP Agent Mail Operations (via HTTP API)
# =============================================================================

def mcp_request(method_name: str, arguments: dict) -> dict:
    """Make a JSON-RPC request to MCP Agent Mail."""
    token = get_bearer_token()
    if not token:
        return {"error": "Bearer token not found. Check ~/mcp_agent_mail/.env"}

    endpoint = get_mcp_endpoint()
    payload = {
        "jsonrpc": "2.0",
        "method": "tools/call",
        "params": {"name": method_name, "arguments": arguments},
        "id": 1
    }

    if HAS_REQUESTS:
        return _mcp_request_requests(endpoint, payload, token)
    return _mcp_request_urllib(endpoint, payload, token)


def _mcp_request_requests(endpoint: str, payload: dict, token: str) -> dict:
    """Make request using requests library."""
    try:
        response = requests.post(
            endpoint, json=payload,
            headers={"Content-Type": "application/json", "Authorization": f"Bearer {token}"},
            timeout=10
        )
        result = response.json()
        if "error" in result:
            return {"error": result["error"].get("message", "Unknown MCP error")}
        return result.get("result", {})
    except requests.Timeout:
        return {"error": "MCP Agent Mail request timed out"}
    except requests.ConnectionError:
        return {"error": "Cannot connect to MCP Agent Mail. Is the service running?"}
    except requests.RequestException as e:
        return {"error": f"MCP request failed: {e}"}
    except json.JSONDecodeError:
        return {"error": "Invalid JSON response from MCP Agent Mail"}


def _mcp_request_urllib(endpoint: str, payload: dict, token: str) -> dict:
    """Make request using urllib (fallback)."""
    try:
        data = json.dumps(payload).encode('utf-8')
        req = urllib.request.Request(
            endpoint, data=data,
            headers={"Content-Type": "application/json", "Authorization": f"Bearer {token}"}
        )
        with urllib.request.urlopen(req, timeout=10) as response:
            result = json.loads(response.read().decode('utf-8'))
            if "error" in result:
                return {"error": result["error"].get("message", "Unknown MCP error")}
            return result.get("result", {})
    except urllib.error.URLError as e:
        return {"error": f"Cannot connect to MCP Agent Mail: {e.reason}"}
    except json.JSONDecodeError:
        return {"error": "Invalid JSON response from MCP Agent Mail"}
    except Exception as e:
        return {"error": f"MCP request failed: {e}"}


def reserve_files(agent_name: str, paths: list, ttl: int, reason: str) -> dict:
    """Reserve files via MCP Agent Mail."""
    return mcp_request("file_reservation_paths", {
        "project_key": get_project_key(),
        "agent_name": agent_name,
        "paths": paths,
        "ttl_seconds": ttl,
        "exclusive": True,
        "reason": reason
    })


def release_files(agent_name: str) -> dict:
    """Release file reservations (rollback helper)."""
    return mcp_request("release_file_reservations", {
        "project_key": get_project_key(),
        "agent_name": agent_name
    })


# =============================================================================
# Main Logic
# =============================================================================

def claim(bead_id: str, paths: Optional[list], ttl: int, json_output: bool) -> int:
    """Atomically claim a bead and reserve files. Returns exit code."""

    # Step 1: Validate agent registration
    agent_name = get_agent_name()
    if not agent_name:
        error = {
            "success": False,
            "error": "Agent not registered",
            "details": "Run register_agent() or set AGENT_NAME environment variable",
            "bead_id": bead_id
        }
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print("✗ Agent not registered\n")
            print("  You must register before claiming work.")
            print("  Run register_agent() via MCP, or set AGENT_NAME env var.")
        return 1

    # Step 2: Validate bead exists and is claimable
    bead = get_bead(bead_id)
    if not bead:
        error = {"success": False, "error": "Bead not found", "bead_id": bead_id}
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print(f"✗ Bead not found: {bead_id}\n")
            print("  Check the ID and try again: bd list")
        return 1

    bead_status = bead.get("status", "").lower()
    if bead_status != "open":
        error = {
            "success": False,
            "error": "Bead not claimable",
            "details": f"Current status is '{bead_status}', must be 'open'",
            "bead_id": bead_id,
            "current_status": bead_status
        }
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print(f"✗ Bead {bead_id} is not claimable\n")
            print(f"  Current status: {bead_status}")
            print(f"  Only beads with status 'open' can be claimed.")
            if bead_status == "in_progress":
                assignee = bead.get("assignee", "unknown")
                print(f"  Currently assigned to: {assignee}")
        return 1

    # Step 3: Reserve files (if paths provided)
    reservation_made = False
    if paths:
        reservation = reserve_files(agent_name, paths, ttl, bead_id)

        if "error" in reservation:
            error = {
                "success": False,
                "error": "File reservation failed",
                "details": reservation["error"],
                "bead_id": bead_id
            }
            if json_output:
                print(json.dumps(error, indent=2))
            else:
                print(f"✗ Failed to claim {bead_id}\n")
                print(f"  File reservation failed: {reservation['error']}\n")
                print("  Options:")
                print("  1. Wait for the other agent to release")
                print("  2. Message them via Agent Mail")
                print("  3. Choose a different bead: bd ready")
            return 1

        conflicts = reservation.get("conflicts", [])
        if conflicts:
            error = {
                "success": False,
                "error": "File reservation conflict",
                "details": conflicts,
                "bead_id": bead_id
            }
            if json_output:
                print(json.dumps(error, indent=2))
            else:
                print(f"✗ Failed to claim {bead_id}\n")
                print("  File reservation conflict:")
                for conflict in conflicts:
                    path = conflict.get("path", "unknown")
                    holders = conflict.get("holders", [])
                    holder_info = ", ".join(holders) if holders else "another agent"
                    print(f"    {path} reserved by {holder_info}")
                print("\n  Options:")
                print("  1. Wait for the other agent to release")
                print("  2. Message them via Agent Mail")
                print("  3. Choose a different bead: bd ready")
            return 1

        reservation_made = True

    # Step 4: Update bead status and assignee
    update_result = update_bead_status(bead_id, agent_name)

    if "error" in update_result:
        if reservation_made:
            release_files(agent_name)  # Rollback

        error = {
            "success": False,
            "error": "Bead update failed",
            "details": update_result["error"],
            "bead_id": bead_id,
            "rollback": "File reservations released" if reservation_made else None
        }
        if json_output:
            print(json.dumps(error, indent=2))
        else:
            print(f"✗ Failed to update {bead_id}\n")
            print(f"  Error: {update_result['error']}")
            if reservation_made:
                print("  (File reservations have been released)")
        return 1

    # Step 5: Update local state file
    try:
        state = load_state()
        state["issue_id"] = bead_id
        state["reservations"] = [{"paths": paths, "reason": bead_id}] if paths else []
        state["claim_time"] = time.time()
        save_state(state)
    except (IOError, TimeoutError) as e:
        if not json_output:
            print(f"  Warning: Could not update state file: {e}")

    # Step 6: Success
    project_key = get_project_key()
    expires_at = datetime.now(timezone.utc) + timedelta(seconds=ttl)

    success = {
        "success": True,
        "bead_id": bead_id,
        "title": bead.get("title", ""),
        "status": "in_progress",
        "assignee": agent_name,
        "files_reserved": paths or [],
        "ttl_seconds": ttl if paths else None,
        "expires_at": expires_at.isoformat() if paths else None,
        "agent": agent_name,
        "project_key": project_key
    }

    if json_output:
        print(json.dumps(success, indent=2))
    else:
        print(f"✓ Claimed {bead_id}: \"{bead.get('title', '')}\"")
        print(f"  Status:    in_progress")
        print(f"  Assignee:  {agent_name}")
        if paths:
            print(f"  Files:     {', '.join(paths)}")
            hours = ttl // 3600
            minutes = (ttl % 3600) // 60
            ttl_str = f"{hours}h {minutes}m" if hours else f"{minutes}m"
            print(f"  TTL:       {ttl_str} (expires {expires_at.strftime('%H:%M')})")
        print(f"  Project:   {project_key}")

    return 0


# =============================================================================
# Entry Point
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Atomically claim a bead and reserve files",
        prog="bd-claim",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  bd-claim bd-a1b2 --paths "src/**/*.py"
  bd-claim bd-a1b2 --paths "src/**/*.py,tests/**/*.py" --ttl 7200
  bd-claim bd-a1b2 --json

This command:
  1. Validates you are registered with MCP Agent Mail
  2. Checks the bead exists and has status 'open'
  3. Reserves the specified files (if --paths provided)
  4. Updates the bead status to 'in_progress' with you as assignee
  5. Updates your local state file

If file reservation succeeds but bead update fails, the reservations
are automatically released (atomic rollback).
        """
    )

    parser.add_argument("bead_id", help="Bead ID to claim (e.g., bd-a1b2)")
    parser.add_argument("--paths", "-p",
        help="Comma-separated glob patterns for file reservation")
    parser.add_argument("--ttl", "-t", type=int, default=DEFAULT_TTL,
        help=f"Reservation TTL in seconds (default: {DEFAULT_TTL})")
    parser.add_argument("--json", action="store_true", dest="json_output",
        help="Output JSON instead of human-readable text")

    args = parser.parse_args()

    paths = None
    if args.paths:
        paths = [p.strip() for p in args.paths.split(",") if p.strip()]

    sys.exit(claim(args.bead_id, paths, args.ttl, args.json_output))


if __name__ == "__main__":
    main()
