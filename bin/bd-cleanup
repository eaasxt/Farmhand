#!/usr/bin/env python3
"""
bd-cleanup - Multi-Agent Workflow Recovery Utility
--------------------------------------------------
Usage:
  bd-cleanup              # Interactive
  bd-cleanup --list       # List orphaned items
  bd-cleanup --force      # Force cleanup stale items
  bd-cleanup --release-all # Release all reservations
  bd-cleanup --reset-state # Reset local agent state
"""

import argparse
import json
import os
import subprocess
import sys
import time
from pathlib import Path

STATE_FILE = Path.home() / ".claude" / "agent-state.json"
MCP_STORAGE = Path.home() / ".mcp_agent_mail"
BEADS_DB = os.environ.get("BEADS_DB", str(Path.home() / ".beads" / "beads.db"))

def get_orphaned_reservations(stale_hours=4):
    orphaned = []
    reservations_dir = MCP_STORAGE / "reservations"
    if not reservations_dir.exists():
        return orphaned

    now = time.time()
    for res_file in reservations_dir.glob("*.json"):
        try:
            with open(res_file) as f:
                data = json.load(f)
                created_at = data.get("created_at", 0)
                expires_at = data.get("expires_at", 0)
                age_hours = (now - created_at) / 3600 if created_at else 0
                orphaned.append({
                    "file": res_file,
                    "agent": data.get("agent_name", "unknown"),
                    "paths": data.get("paths", []),
                    "reason": data.get("reason", ""),
                    "age_hours": round(age_hours, 1),
                    "is_expired": expires_at < now,
                    "is_stale": age_hours > stale_hours,
                })
        except (json.JSONDecodeError, IOError) as e:
            orphaned.append({"file": res_file, "error": str(e), "is_corrupted": True})
    return orphaned

def get_stuck_issues():
    stuck = []
    try:
        bd_path = Path.home() / ".local" / "bin" / "bd"
        if not bd_path.exists():
            return stuck
        result = subprocess.run(
            [str(bd_path), "list", "--status=in_progress", "--json"],
            capture_output=True, text=True, timeout=10,
            env={**os.environ, "BEADS_DB": BEADS_DB}
        )
        if result.returncode == 0 and result.stdout.strip():
            issues = json.loads(result.stdout)
            now = time.time()
            for issue in issues:
                updated = issue.get("updated_at", 0)
                if isinstance(updated, str):
                    from datetime import datetime
                    try:
                        dt = datetime.fromisoformat(updated.replace("Z", "+00:00"))
                        updated = dt.timestamp()
                    except:
                        updated = 0
                age_hours = (now - updated) / 3600 if updated else 0
                if age_hours > 24:
                    stuck.append({"id": issue.get("id", ""), "title": issue.get("title", ""), "age_hours": round(age_hours, 1)})
    except Exception:
        pass
    return stuck

def list_items():
    print("=" * 60)
    print("MULTI-AGENT WORKFLOW CLEANUP")
    print("=" * 60)
    print()

    print("LOCAL AGENT STATE:")
    if STATE_FILE.exists():
        try:
            with open(STATE_FILE) as f:
                state = json.load(f)
                print(f"  Registered: {state.get('registered', False)}")
                print(f"  Agent: {state.get('agent_name', 'None')}")
                print(f"  Reservations: {len(state.get('reservations', []))}")
        except:
            print("  (corrupted)")
    else:
        print("  (none)")
    print()

    orphaned = get_orphaned_reservations()
    print(f"FILE RESERVATIONS: ({len(orphaned)} total)")
    for res in orphaned:
        if res.get("is_corrupted"):
            print(f"  [CORRUPTED] {res['file']}")
        else:
            status = []
            if res["is_expired"]: status.append("EXPIRED")
            if res["is_stale"]: status.append("STALE")
            status_str = f" [{', '.join(status)}]" if status else ""
            print(f"  {res['agent']}: {res['paths'][:2]}{status_str} ({res['age_hours']}h)")
    if not orphaned:
        print("  (none)")
    print()

    stuck = get_stuck_issues()
    print(f"STUCK ISSUES (>24h in_progress): ({len(stuck)} total)")
    for issue in stuck:
        print(f"  {issue['id']}: {issue['title'][:40]} ({issue['age_hours']}h)")
    if not stuck:
        print("  (none)")
    print()

def reset_state():
    if STATE_FILE.exists():
        os.remove(STATE_FILE)
        print("Local agent state reset.")
    else:
        print("No local state to reset.")

def force_cleanup(stale_hours=4):
    print("Force cleanup...")
    reset_state()
    orphaned = get_orphaned_reservations(stale_hours)
    removed = 0
    for res in orphaned:
        if res.get("is_corrupted") or res.get("is_expired") or res.get("is_stale"):
            try:
                os.remove(res["file"])
                removed += 1
            except:
                pass
    print(f"Removed {removed} reservations.")

def release_all():
    print("WARNING: This releases ALL reservations!")
    response = input("Are you sure? (yes/no): ")
    if response.lower() != "yes":
        print("Aborted.")
        return
    reservations_dir = MCP_STORAGE / "reservations"
    if reservations_dir.exists():
        removed = 0
        for res_file in reservations_dir.glob("*.json"):
            try:
                os.remove(res_file)
                removed += 1
            except:
                pass
        print(f"Released {removed} reservations.")
    reset_state()

def interactive():
    list_items()
    print("-" * 60)
    print("1. Reset local state  2. Cleanup stale  3. Release ALL  4. Exit")
    choice = input("Select (1-4): ").strip()
    if choice == "1": reset_state()
    elif choice == "2": force_cleanup()
    elif choice == "3": release_all()

def main():
    parser = argparse.ArgumentParser(description="Multi-agent workflow cleanup")
    parser.add_argument("--list", "-l", action="store_true")
    parser.add_argument("--force", "-f", action="store_true")
    parser.add_argument("--release-all", action="store_true")
    parser.add_argument("--reset-state", action="store_true")
    args = parser.parse_args()

    if args.list: list_items()
    elif args.force: force_cleanup()
    elif args.release_all: release_all()
    elif args.reset_state: reset_state()
    else: interactive()

if __name__ == "__main__":
    main()
