#!/usr/bin/env python3
"""
bd-cleanup - Multi-Agent Workflow Cleanup Utility (v2 - SQLite)
---------------------------------------------------------------
Handles recovery from crashes, interrupts, and orphaned state.
Queries MCP Agent Mail SQLite database directly for reservations.

Usage:
  bd-cleanup                    # Interactive cleanup
  bd-cleanup --list             # List orphaned items
  bd-cleanup --force            # Force cleanup all stale items
  bd-cleanup --release-all      # Release all reservations
  bd-cleanup --reset-state      # Reset local agent state
  bd-cleanup --clean-locks      # Clean up stale lock files only
"""

import argparse
import json
import os
import sys
import time
import sqlite3
from datetime import datetime, timezone
from pathlib import Path

# Per-agent state files to avoid conflicts in multi-agent
AGENT_NAME = os.environ.get("AGENT_NAME")
STATE_DIR = Path.home() / ".claude"
MCP_DB_PATH = Path.home() / "mcp_agent_mail" / "storage.sqlite3"
BEADS_DB = os.environ.get("BEADS_DB", str(Path.home() / ".beads" / "beads.db"))

def get_state_file():
    """Get the state file path for this agent."""
    if AGENT_NAME:
        return STATE_DIR / f"state-{AGENT_NAME}.json"
    else:
        return STATE_DIR / "agent-state.json"

def get_orphaned_reservations(stale_hours=4):
    """Find reservations that may be orphaned from SQLite database."""
    orphaned = []

    if not MCP_DB_PATH.exists():
        return orphaned

    try:
        conn = sqlite3.connect(str(MCP_DB_PATH), timeout=30.0)
        # Enable WAL mode for better concurrency with multiple agents
        conn.execute('PRAGMA journal_mode=WAL')
        conn.execute('PRAGMA busy_timeout=30000')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        now = datetime.now(timezone.utc)
        now_str = now.strftime("%Y-%m-%d %H:%M:%S")

        # Get all non-released reservations
        cursor.execute("""
            SELECT
                fr.id,
                fr.path_pattern,
                fr.reason,
                fr.created_ts,
                fr.expires_ts,
                fr.released_ts,
                a.name as agent_name
            FROM file_reservations fr
            JOIN agents a ON fr.agent_id = a.id
            WHERE fr.released_ts IS NULL
            ORDER BY fr.created_ts DESC
        """)

        for row in cursor.fetchall():
            try:
                created_str = row["created_ts"]
                expires_str = row["expires_ts"]

                # Parse timestamps (database stores as naive UTC, make them aware)
                created = datetime.fromisoformat(created_str.replace('Z', '+00:00'))
                if created.tzinfo is None:
                    created = created.replace(tzinfo=timezone.utc)
                expires = datetime.fromisoformat(expires_str.replace('Z', '+00:00'))
                if expires.tzinfo is None:
                    expires = expires.replace(tzinfo=timezone.utc)

                age_hours = (now - created).total_seconds() / 3600
                is_expired = expires < now
                is_stale = age_hours > stale_hours

                orphaned.append({
                    "id": row["id"],
                    "agent": row["agent_name"],
                    "paths": [row["path_pattern"]],
                    "reason": row["reason"] or "",
                    "age_hours": round(age_hours, 1),
                    "is_expired": is_expired,
                    "is_stale": is_stale,
                    "expires_ts": expires_str,
                })
            except (ValueError, AttributeError) as e:
                orphaned.append({
                    "id": row["id"],
                    "agent": row["agent_name"],
                    "paths": [row["path_pattern"]],
                    "error": str(e),
                    "is_corrupted": True
                })

        conn.close()
    except sqlite3.Error as e:
        print(f"Warning: Could not read database: {e}", file=sys.stderr)

    return orphaned

def get_stuck_issues():
    """Find issues that are in_progress but may be abandoned."""
    stuck = []
    try:
        import subprocess
        bd_path = Path.home() / ".local" / "bin" / "bd"
        result = subprocess.run(
            [str(bd_path), "list", "--status=in_progress", "--json"],
            capture_output=True, text=True, timeout=10,
            env={**os.environ, "BEADS_DB": BEADS_DB}
        )
        if result.returncode == 0:
            issues = json.loads(result.stdout)
            now = time.time()
            for issue in issues:
                # Check if issue has been in_progress for too long
                updated = issue.get("updated_at", 0)
                if isinstance(updated, str):
                    # Parse ISO timestamp
                    try:
                        dt = datetime.fromisoformat(updated.replace("Z", "+00:00"))
                        updated = dt.timestamp()
                    except (ValueError, AttributeError):
                        updated = 0

                age_hours = (now - updated) / 3600 if updated else 0
                if age_hours > 24:  # Stuck for more than 24 hours
                    stuck.append({
                        "id": issue.get("id", ""),
                        "title": issue.get("title", ""),
                        "age_hours": round(age_hours, 1),
                    })
    except Exception as e:
        print(f"Warning: Could not check issues: {e}", file=sys.stderr)

    return stuck

def list_items():
    """List all orphaned/stuck items."""
    print("=" * 60)
    print("MULTI-AGENT WORKFLOW CLEANUP (v2 - SQLite)")
    print("=" * 60)
    print()

    # Local state
    state_file = get_state_file()
    print(f"LOCAL AGENT STATE: ({state_file.name})")
    if state_file.exists():
        try:
            with open(state_file) as f:
                state = json.load(f)
                print(f"  Registered: {state.get('registered', False)}")
                print(f"  Agent Name: {state.get('agent_name', 'None')}")
                print(f"  Issue ID: {state.get('issue_id', 'None')}")
                print(f"  Reservations: {len(state.get('reservations', []))}")
        except (json.JSONDecodeError, IOError):
            print("  (corrupted)")
    else:
        print("  (none)")
    print()

    # Reservations from SQLite
    orphaned = get_orphaned_reservations()
    print(f"FILE RESERVATIONS (from SQLite): ({len(orphaned)} active)")
    if orphaned:
        for res in orphaned:
            if res.get("is_corrupted"):
                print(f"  [CORRUPTED] ID {res['id']}: {res.get('agent', 'unknown')}")
            else:
                status = []
                if res.get("is_expired"):
                    status.append("EXPIRED")
                if res.get("is_stale"):
                    status.append("STALE")
                status_str = f" [{', '.join(status)}]" if status else ""
                print(f"  {res['agent']}: {res['paths']}{status_str}")
                print(f"    ID: {res['id']} | Age: {res['age_hours']}h | Reason: {res['reason']}")
    else:
        print("  (none)")
    print()

    # Stuck issues
    stuck = get_stuck_issues()
    print(f"POTENTIALLY STUCK ISSUES: ({len(stuck)} total)")
    if stuck:
        for issue in stuck:
            print(f"  {issue['id']}: {issue['title']} ({issue['age_hours']}h)")
    else:
        print("  (none)")
    print()

    # Stale lock files
    stale_locks = get_stale_lock_files()
    print(f"STALE LOCK FILES: ({len(stale_locks)} total)")
    if stale_locks:
        for lock_info in stale_locks:
            print(f"  {lock_info['path'].name}: {lock_info['age_hours']}h old")
    else:
        print("  (none)")
    print()

def get_stale_lock_files(stale_hours=1):
    """Find lock files that are older than stale_hours."""
    stale_locks = []
    if not STATE_DIR.exists():
        return stale_locks

    cutoff = time.time() - (stale_hours * 3600)
    for lock_file in STATE_DIR.glob("*.lock"):
        try:
            mtime = lock_file.stat().st_mtime
            if mtime < cutoff:
                age_hours = (time.time() - mtime) / 3600
                stale_locks.append({
                    "path": lock_file,
                    "age_hours": round(age_hours, 1)
                })
        except OSError:
            pass  # File may have been deleted

    return stale_locks


def cleanup_stale_locks(stale_hours=1):
    """Remove stale lock files."""
    stale_locks = get_stale_lock_files(stale_hours)
    removed = 0
    for lock_info in stale_locks:
        try:
            lock_info["path"].unlink()
            removed += 1
            print(f"  Removed stale lock: {lock_info['path'].name} ({lock_info['age_hours']}h old)")
        except OSError as e:
            print(f"  Failed to remove {lock_info['path'].name}: {e}")
    return removed


def reset_state():
    """Reset local agent state (only for this agent, not others)."""
    state_file = get_state_file()
    lock_file = state_file.with_suffix('.lock')

    # Remove state file
    if state_file.exists():
        os.remove(state_file)
        agent_id = AGENT_NAME or "default"
        print(f"Local agent state reset for {agent_id}.")
    else:
        print("No local state to reset.")

    # Also remove associated lock file
    if lock_file.exists():
        try:
            lock_file.unlink()
            print(f"Lock file removed: {lock_file.name}")
        except OSError:
            pass

def release_reservation_by_id(res_id):
    """Mark a reservation as released in the SQLite database."""
    try:
        conn = sqlite3.connect(str(MCP_DB_PATH), timeout=30.0)
        # Enable WAL mode for better concurrency with multiple agents
        conn.execute('PRAGMA journal_mode=WAL')
        conn.execute('PRAGMA busy_timeout=30000')
        cursor = conn.cursor()
        now_str = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S.%f")
        cursor.execute(
            "UPDATE file_reservations SET released_ts = ? WHERE id = ?",
            (now_str, res_id)
        )
        conn.commit()
        conn.close()
        return True
    except sqlite3.Error as e:
        print(f"Failed to release reservation {res_id}: {e}", file=sys.stderr)
        return False

def force_cleanup(stale_hours=4):
    """Force cleanup all stale/expired items."""
    print("Force cleanup starting...")

    # Reset local state
    reset_state()

    # Clean up stale lock files
    locks_removed = cleanup_stale_locks()
    if locks_removed:
        print(f"  Removed {locks_removed} stale lock file(s).")

    # Release stale/expired reservations in database
    orphaned = get_orphaned_reservations(stale_hours)
    released = 0
    for res in orphaned:
        if res.get("is_corrupted") or res.get("is_expired") or res.get("is_stale"):
            if release_reservation_by_id(res["id"]):
                released += 1
                print(f"  Released: {res.get('agent', 'corrupted')} reservation (ID {res['id']})")

    print(f"Cleanup complete. Released {released} reservations.")

def release_all():
    """Release ALL reservations (nuclear option)."""
    print("WARNING: This will release ALL file reservations!")
    response = input("Are you sure? (yes/no): ")
    if response.lower() != "yes":
        print("Aborted.")
        return

    orphaned = get_orphaned_reservations(stale_hours=0)
    released = 0
    for res in orphaned:
        if release_reservation_by_id(res["id"]):
            released += 1

    print(f"Released {released} reservations.")
    reset_state()

def interactive_cleanup():
    """Interactive cleanup mode."""
    list_items()

    print("-" * 60)
    print("OPTIONS:")
    print("  1. Reset local agent state")
    print("  2. Release expired/stale reservations")
    print("  3. Release ALL reservations (nuclear)")
    print("  4. Clean up stale lock files only")
    print("  5. Exit")
    print()

    choice = input("Select option (1-5): ").strip()

    if choice == "1":
        reset_state()
    elif choice == "2":
        force_cleanup()
    elif choice == "3":
        release_all()
    elif choice == "4":
        removed = cleanup_stale_locks()
        if removed:
            print(f"Removed {removed} stale lock file(s).")
        else:
            print("No stale lock files found.")
    elif choice == "5":
        print("Exiting.")
    else:
        print("Invalid option.")

def main():
    parser = argparse.ArgumentParser(description="Multi-agent workflow cleanup utility")
    parser.add_argument("--list", "-l", action="store_true", help="List orphaned items")
    parser.add_argument("--force", "-f", action="store_true", help="Force cleanup stale items")
    parser.add_argument("--release-all", action="store_true", help="Release all reservations")
    parser.add_argument("--reset-state", action="store_true", help="Reset local agent state")
    parser.add_argument("--clean-locks", action="store_true", help="Clean up stale lock files only")
    parser.add_argument("--stale-hours", type=int, default=4, help="Hours before considered stale")

    args = parser.parse_args()

    if args.list:
        list_items()
    elif args.force:
        force_cleanup(args.stale_hours)
    elif args.release_all:
        release_all()
    elif args.reset_state:
        reset_state()
    elif args.clean_locks:
        removed = cleanup_stale_locks()
        if removed:
            print(f"Removed {removed} stale lock file(s).")
        else:
            print("No stale lock files found.")
    else:
        interactive_cleanup()

if __name__ == "__main__":
    main()
