#!/usr/bin/env python3
"""
Gas Town tmux Integration
========================

Makes tmux the primary interface for Gas Town multi-agent orchestration.
Implements Steve Yegge's vision of tmux as the central coordination hub.

Features:
- Auto-discovery of agent sessions
- Gas Town status bar integration
- Seamless gt command integration
- Agent pane management and coordination
- Real-time hook status display
- Session lifecycle management

Usage:
    python3 gas_town_tmux.py setup       # Setup tmux Gas Town configuration
    python3 gas_town_tmux.py status-bar  # Update status bar with Gas Town data
    python3 gas_town_tmux.py discover    # Discover and list agent sessions
    python3 gas_town_tmux.py spawn       # Spawn new agent session
    ./gt tmux <command>                   # Integration commands
"""

import os
import sys
import json
import subprocess
import time
import argparse
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

# Add our modules to the path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from hook_system import GasTownHookSystem


class GasTownTmux:
    """Gas Town tmux integration manager."""

    def __init__(self):
        self.hook_system = GasTownHookSystem()
        self.gas_town_dir = Path.home() / ".gas_town"
        self.gas_town_dir.mkdir(exist_ok=True)
        self.tmux_config_dir = Path.home() / ".tmux"
        self.tmux_config_dir.mkdir(exist_ok=True)

        # Gas Town roles for agent identification
        self.gas_town_roles = [
            'mayor', 'witness', 'refinery', 'deacon', 'crew', 'polecat',
            'gas', 'town', 'agent', 'worker', 'coordinator'
        ]

    def setup_tmux_config(self) -> bool:
        """Setup tmux configuration for Gas Town integration."""
        try:
            print("üîß Setting up Gas Town tmux integration...")

            # Create Gas Town tmux configuration
            tmux_config = self.create_gas_town_tmux_config()

            # Write to tmux config file
            tmux_config_file = Path.home() / ".tmux.conf.gasetown"
            with open(tmux_config_file, 'w') as f:
                f.write(tmux_config)

            print(f"‚úÖ Gas Town tmux config written to {tmux_config_file}")

            # Create status bar update script
            status_script = self.create_status_bar_script()
            status_script_file = self.gas_town_dir / "tmux_status.sh"
            with open(status_script_file, 'w') as f:
                f.write(status_script)
            os.chmod(status_script_file, 0o755)

            print(f"‚úÖ Status bar script created at {status_script_file}")

            # Instructions for user
            print(f"\nüìã To enable Gas Town tmux integration:")
            print(f"   1. Add to your ~/.tmux.conf:")
            print(f"      source-file ~/.tmux.conf.gasetown")
            print(f"   2. Reload tmux config:")
            print(f"      tmux source-file ~/.tmux.conf")
            print(f"   3. Or start new tmux session:")
            print(f"      tmux new-session -s gas-town")

            return True

        except Exception as e:
            print(f"‚ùå tmux setup failed: {e}")
            return False

    def create_gas_town_tmux_config(self) -> str:
        """Create Gas Town-specific tmux configuration."""
        current_dir = os.getcwd()
        status_script_path = os.path.join(str(self.gas_town_dir), 'tmux_status.sh')

        config = f'''# Gas Town tmux Configuration
# Auto-generated by Gas Town tmux integration

# Gas Town key bindings
bind-key g display-popup -E "cd {current_dir} && ./gt status"
bind-key G display-popup -E -w 90% -h 90% "cd {current_dir} && ./gt dashboard"
bind-key h display-popup -E "cd {current_dir} && ./gt hooks"
bind-key C display-popup -E "cd {current_dir} && ./gt convoy list"

# Gas Town pane management
bind-key M split-window -h -c "{current_dir}" "bash -c 'export AGENT_NAME=Mayor-$(date +%s) && echo Gas Town Mayor Agent && bash'"
bind-key W split-window -h -c "{current_dir}" "bash -c 'export AGENT_NAME=Witness-$(date +%s) && echo Gas Town Witness Agent && bash'"
bind-key R split-window -h -c "{current_dir}" "bash -c 'export AGENT_NAME=Refinery-$(date +%s) && echo Gas Town Refinery Agent && bash'"
bind-key D split-window -h -c "{current_dir}" "bash -c 'export AGENT_NAME=Deacon-$(date +%s) && echo Gas Town Deacon Agent && bash'"

# Status bar with Gas Town information
set -g status-right-length 120
set -g status-right "#[fg=yellow]‚ö°#({status_script_path}) #[fg=green]%H:%M #[fg=blue]%Y-%m-%d"
set -g status-interval 5

# Gas Town session naming
set -g automatic-rename on
set -g automatic-rename-format "#{{=15:pane_title}}"

# Mouse support for easier pane management
set -g mouse on

# Gas Town color scheme
set -g status-style bg=colour235,fg=colour136
set -g status-left "#[fg=colour166,bold]üè≠ Gas Town #[fg=colour244]| "
set -g window-status-current-style bg=colour166,fg=colour235,bold

# Pane borders
set -g pane-border-style fg=colour238
set -g pane-active-border-style fg=colour166

# Command mode
set -g command-style bg=colour166,fg=colour235

# Message style
set -g message-style bg=colour166,fg=colour235,bold
'''
        return config

    def create_status_bar_script(self) -> str:
        """Create status bar update script for Gas Town information."""
        script_path = os.path.abspath(__file__)
        script = f'''#!/bin/bash
# Gas Town tmux status bar script
# Shows live hook and agent information

python3 "{script_path}" status-bar-data 2>/dev/null || echo "üè≠ Gas Town"
'''
        return script

    def get_status_bar_data(self) -> str:
        """Get Gas Town status data for tmux status bar."""
        try:
            # Get hook system data
            all_hooks = self.hook_system.list_all_hooks()
            total_pending = sum(hook['pending_work'] for hook in all_hooks)

            # Get active agent sessions
            agent_sessions = self.discover_agent_sessions()

            # Format status bar text
            status_parts = []
            status_parts.append(f"ü™ù{len(all_hooks)}")

            if total_pending > 0:
                if total_pending > 10:
                    status_parts.append(f"üìã{total_pending}!")
                elif total_pending > 5:
                    status_parts.append(f"üìã{total_pending}")
                else:
                    status_parts.append(f"üìã{total_pending}")

            if agent_sessions:
                status_parts.append(f"üë•{len(agent_sessions)}")

            # Check GUPP status
            try:
                result = subprocess.run(["pgrep", "-f", "gupp_auto_execution"], capture_output=True)
                if result.returncode == 0:
                    status_parts.append("‚ö°")
            except:
                pass

            return " ".join(status_parts) if status_parts else "üè≠ Gas Town"

        except Exception as e:
            return f"üè≠ Gas Town ({str(e)[:10]})"

    def discover_agent_sessions(self) -> List[Dict[str, str]]:
        """Discover active Gas Town agent sessions."""
        try:
            result = subprocess.run(["tmux", "list-sessions"], capture_output=True, text=True)
            if result.returncode != 0:
                return []

            sessions = []
            for line in result.stdout.split('\n'):
                if not line.strip():
                    continue

                session_name = line.split(':')[0]

                # Check if this looks like a Gas Town agent session
                if any(role in session_name.lower() for role in self.gas_town_roles):
                    # Parse session details
                    session_info = {
                        'name': session_name,
                        'line': line.strip(),
                        'type': 'agent',
                        'role': self.identify_agent_role(session_name)
                    }

                    # Check if session has windows
                    if 'windows' in line:
                        window_info = [part for part in line.split() if 'window' in part]
                        session_info['windows'] = window_info[0] if window_info else '1 window'

                    # Check attachment status
                    session_info['attached'] = 'attached' in line

                    sessions.append(session_info)

            return sessions

        except Exception as e:
            print(f"Session discovery error: {e}")
            return []

    def identify_agent_role(self, session_name: str) -> str:
        """Identify the Gas Town role from session name."""
        name_lower = session_name.lower()
        for role in ['mayor', 'witness', 'refinery', 'deacon', 'crew', 'polecat']:
            if role in name_lower:
                return role.title()
        return "Agent"

    def create_session(self, role: str = "Agent", session_name: Optional[str] = None) -> bool:
        """Create a new Gas Town agent session (alias for spawn_agent_session)."""
        return self.spawn_agent_session(role, session_name)

    def list_sessions(self) -> List[Dict[str, str]]:
        """List all Gas Town agent sessions (alias for discover_agent_sessions)."""
        return self.discover_agent_sessions()

    def get_sessions(self) -> List[Dict[str, str]]:
        """Get all Gas Town agent sessions (alias for discover_agent_sessions)."""
        return self.discover_agent_sessions()

    def spawn_agent_session(self, role: str = "Agent", session_name: Optional[str] = None) -> bool:
        """Spawn a new Gas Town agent session."""
        try:
            if not session_name:
                timestamp = int(time.time())
                session_name = f"gasetown-{role.lower()}-{timestamp}"

            agent_name = f"{role}-{timestamp}"

            print(f"üöÄ Spawning Gas Town {role} session: {session_name}")

            # Create new tmux session
            cmd = [
                "tmux", "new-session", "-d", "-s", session_name,
                "bash", "-c",
                f"export AGENT_NAME={agent_name} && "
                f"echo 'üè≠ Gas Town {role} Agent: {agent_name}' && "
                f"echo 'Session: {session_name}' && "
                f"echo 'Ready for work. Use: gt hooks {agent_name} --action create' && "
                "bash"
            ]

            result = subprocess.run(cmd)
            if result.returncode == 0:
                print(f"‚úÖ Session {session_name} created successfully")
                print(f"üí° Attach with: tmux attach -t {session_name}")

                # Optionally create hook for this agent
                try:
                    hook_id = self.hook_system.create_agent_hook(agent_name, {"role": role.lower()})
                    print(f"ü™ù Hook created for {agent_name}: {hook_id}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Hook creation failed: {e}")

                return True
            else:
                print(f"‚ùå Failed to create session {session_name}")
                return False

        except Exception as e:
            print(f"‚ùå Agent spawn failed: {e}")
            return False

    def list_agent_sessions(self) -> None:
        """List all Gas Town agent sessions with details."""
        print("üè≠ GAS TOWN AGENT SESSIONS")
        print("=" * 50)

        sessions = self.discover_agent_sessions()

        if not sessions:
            print("No Gas Town agent sessions found.")
            print("\nüí° Create new agent session with:")
            print("   ./gt tmux spawn <role>")
            return

        for session in sessions:
            status_icon = "üü¢" if session.get('attached') else "üî¥"
            role = session.get('role', 'Agent')
            windows = session.get('windows', '1 window')

            print(f"{status_icon} {session['name']}")
            print(f"   Role: {role}")
            print(f"   Windows: {windows}")
            print(f"   Status: {'Attached' if session.get('attached') else 'Detached'}")

            # Try to get hook information for this agent
            try:
                # Extract agent name from session name
                potential_agent_names = [
                    session['name'],
                    session['name'].replace('gasetown-', ''),
                    f"{role}-{session['name'].split('-')[-1]}" if '-' in session['name'] else role
                ]

                hook_info_found = False
                for agent_name in potential_agent_names:
                    try:
                        pending = self.hook_system.check_hook(agent_name)
                        print(f"   Hook: {agent_name} - {len(pending)} pending work")
                        hook_info_found = True
                        break
                    except:
                        continue

                if not hook_info_found:
                    print(f"   Hook: Not found or not created")

            except Exception as e:
                print(f"   Hook: Error checking ({e})")

            print()

    def integrate_gt_commands(self) -> None:
        """Show integration examples for gt commands in tmux."""
        print("üîó GAS TOWN TMUX INTEGRATION")
        print("=" * 50)
        print("Key bindings (when tmux config is loaded):")
        print()
        print("   g    - Quick status (popup)")
        print("   G    - Dashboard (full popup)")
        print("   h    - Hook management")
        print("   C    - Convoy list")
        print()
        print("Agent session spawning:")
        print("   M    - New Mayor pane")
        print("   W    - New Witness pane")
        print("   R    - New Refinery pane")
        print("   D    - New Deacon pane")
        print()
        print("Command line integration:")
        print("   ./gt tmux setup     - Setup tmux configuration")
        print("   ./gt tmux spawn     - Spawn new agent session")
        print("   ./gt tmux discover  - List agent sessions")
        print("   ./gt tmux integrate - Show this help")
        print()
        print("Status bar shows: ü™ùhooks üìãpending üë•agents ‚ö°GUPP")

    def attach_to_agent(self, session_name: str) -> bool:
        """Attach to an existing agent session."""
        try:
            sessions = self.discover_agent_sessions()
            matching_sessions = [s for s in sessions if session_name in s['name']]

            if not matching_sessions:
                print(f"‚ùå No agent session found matching: {session_name}")
                print("Available sessions:")
                for session in sessions:
                    print(f"   ‚Ä¢ {session['name']}")
                return False

            target_session = matching_sessions[0]['name']
            print(f"üîó Attaching to session: {target_session}")

            # Attach to session
            subprocess.run(["tmux", "attach", "-t", target_session])
            return True

        except Exception as e:
            print(f"‚ùå Attach failed: {e}")
            return False

    def kill_agent_session(self, session_name: str) -> bool:
        """Safely kill an agent session with cleanup."""
        try:
            sessions = self.discover_agent_sessions()
            matching_sessions = [s for s in sessions if session_name in s['name']]

            if not matching_sessions:
                print(f"‚ùå No agent session found matching: {session_name}")
                return False

            target_session = matching_sessions[0]['name']
            print(f"üóëÔ∏è Killing session: {target_session}")

            # TODO: Add cleanup logic here
            # - Release file reservations
            # - Complete pending work gracefully
            # - Notify other agents

            result = subprocess.run(["tmux", "kill-session", "-t", target_session])
            if result.returncode == 0:
                print(f"‚úÖ Session {target_session} terminated")
                return True
            else:
                print(f"‚ùå Failed to kill session {target_session}")
                return False

        except Exception as e:
            print(f"‚ùå Session kill failed: {e}")
            return False


def main():
    """Main tmux integration entry point."""
    parser = argparse.ArgumentParser(
        description="Gas Town tmux Integration"
    )

    parser.add_argument(
        "command",
        choices=["setup", "status-bar", "status-bar-data", "discover", "spawn", "integrate", "attach", "kill"],
        help="tmux integration command"
    )

    parser.add_argument(
        "target",
        nargs="?",
        help="Target for spawn/attach/kill commands"
    )

    parser.add_argument(
        "--role",
        choices=["Mayor", "Witness", "Refinery", "Deacon", "Crew", "Polecat", "Agent"],
        default="Agent",
        help="Role for spawned agent"
    )

    args = parser.parse_args()

    tmux = GasTownTmux()

    if args.command == "setup":
        success = tmux.setup_tmux_config()
        return 0 if success else 1

    elif args.command == "status-bar":
        print("Updating tmux status bar...")
        # This would be called periodically by tmux
        return 0

    elif args.command == "status-bar-data":
        # This is called by the tmux status script
        print(tmux.get_status_bar_data())
        return 0

    elif args.command == "discover":
        tmux.list_agent_sessions()
        return 0

    elif args.command == "spawn":
        role = args.target or args.role
        success = tmux.spawn_agent_session(role)
        return 0 if success else 1

    elif args.command == "integrate":
        tmux.integrate_gt_commands()
        return 0

    elif args.command == "attach":
        if not args.target:
            print("‚ùå Session name required for attach")
            return 1
        success = tmux.attach_to_agent(args.target)
        return 0 if success else 1

    elif args.command == "kill":
        if not args.target:
            print("‚ùå Session name required for kill")
            return 1
        success = tmux.kill_agent_session(args.target)
        return 0 if success else 1

    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())